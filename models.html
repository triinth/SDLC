<!DOCTYPE html>
<html lang="en">
<link rel="stylesheet" href="/css/style.css">

<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>SDLC Models</title>
</head>

<body>
    <h2>Accordion</h2>

    <button class="accordion">Waterfall model</button>
    <div class="panel">
        <p>Waterfall Model is a sequential model that divides software development into pre-defined phases. Each phase
            must be completed before the next phase can begin with no overlap between the phases. Each phase is designed
            for performing specific activity during the SDLC phase. It was introduced in 1970 by Winston Royce.</p>
        <img src="images/052615_1232_WhatisSDLCo1.webp" width="300px" alt="waterfall">
        <h3>When to use SDLC Waterfall Model?</h3>

        <b>Waterfall Methodology can be used when:</b>

        <ul>
            <li>Requirements are not changing frequently</li>
            <li>Application is not complicated and big</li>
            <li>Project is short</li>
            <li>Requirement is clear</li>
            <li>Environment is stable</li>
            <li>Technology and tools used are not dynamic and is stable</li>
            <li>Resources are available and trained</li>
        </ul>
        <table>
            <tr>
                <th>Different phases</th>
                <th>Activities performed in each stage</th>
            </tr>
            <tr>
                <td>Requirement Gathering stage</td>
            </tr>

        </table>
    </div>

    <button class="accordion">What is Incremental Model?</button>
    <div class="panel">
        <p>Incremental Model is a process of software development where requirements are broken down into multiple
            standalone modules of software development cycle. Incremental development is done in steps from analysis
            design, implementation, testing/verification, maintenance.</p>
        <img src="images/052615_1049_WhatisIncre1.webp" alt="">
        <p>Each iteration passes through the requirements, design, coding and testing phases. And each subsequent
            release of the system adds function to the previous release until all designed functionality has been
            implemented.</p>
        <img src="images/052615_1049_WhatisIncre2.webp" alt="">
        <p>The system is put into production when the first increment is delivered. The first increment is often a core
            product where the basic requirements are addressed, and supplementary features are added in the next
            increments. Once the core product is analyzed by the client, there is plan development for the next
            increment.</p>
        <h3>Characteristics of an Incremental module includes</h3>
        <ul>
            <li>
                System development is broken down into many mini development projects
            </li>
            <li>
                Partial systems are successively built to produce a final total system
            </li>
            <li>
                Highest priority requirement is tackled first
            </li>
            <li>Once the requirement is developed, requirement for that increment are frozen</li>
        </ul>
        <h3>When to use Incremental models?</h3>
        <ul>
            <li>

                Requirements of the system are clearly understood

            </li>
            <li>
                When demand for an early release of a product arises
            </li>
            <li>
                When high-risk features and goals are involved
            </li>
            <li>When software engineering team are not very well skilled or trained</li>
            <li>Such methodology is more in use for web application and product based companies</li>
        </ul>






    </div>

    <button class="accordion">V Model</button>
    <div class="panel">
        <p>the V model of testing was developed where for every phase, in the Development life cycle there is a
            corresponding Testing phase</p>
        <img src="images/052715_0904_GuidetoSDLC3.webp" alt="">
        <ul>
            <li>

                The left side of the model is Software Development Life Cycle – SDLC</li>
            <li>The right side of the model is Software Test Life Cycle – STLC</li>
            <li>The entire figure looks like a V, hence the name V – model</li>

        </ul>
        <p>Apart from the V model, there are iterative development models, where development is carried in phases, with
            each phase adding a functionality to the software. Each phase comprises its independent set of development
            and testing activities.</p>

        <p>Good examples of Development lifecycles following iterative method are Rapid Application Development, Agile
            Development</p>
    </div>
    <button class="accordion">Agiilsed meetodid</button>
    <div class="panel">
        <h3>Mis on agiilne meetod?</h3>
        <p>Agiilset tarkvaraprogrammi võib kirjeldada kui loetelu tarkvaraprogrammi lahendustest, millel on nii soove kui ka võimalusi, mis on välja arendatud, kasutades koostööd iseorganiseeruvate ja funktsionaalsete rühmade vahel.</p>

           <p>See edendab adaptiivset planeerimist, evolutsioonilist arengut ja varajast edastamist teie väga iteratiivsetele ja järkjärgulistele lähenemisviisidele tarkvaraarendusele.</p>
        <h3>Millal hakati kasutama?</h3>
        <p>1990. aastate alguses lõid Ken Schwaber ja Jeff Sutherland Scrumi metoodika</p>
        <img src="images/agile_Processesv1_1.webp" alt="">
        <h3>Miks just agiilne meetod?</h3>
        <p>Agiilset tehnikat kasutanud ettevõtted saavad reageerida turudünaamikale ja seostada kõigi oma projektidega tõhusalt. Agiilsed koolitused on suurepärane viis nii ettevõtte kui ka projektirühma seadistamiseks agiilse ja ühendatud täitmismeetodi alustalades. Agiilsed koolitused võivad selgeks teha hulga müüte ja arusaamatusi seoses Agile protseduuridega. Samuti võib see toetada ja paljastada Agiilsete ideede põhialuseid ning selgitada erinevate teostuslahenduste erinevusi.</p>
        <h3>8 printsiipi</h3>
         <ul><li>Keskendu ettevõtte vajadustele (Focus on the business need)</li>
           <li> Tarni õigel ajal (Deliver on time)</li>
            <li>Koostöö ('Collaborate')</li>
            <li>Ära kunagi anna kvaliteedis järele (Never compromise quality)</li>
            <li>Ehita järk-järgult (Build incrementally from firm foundations)</li>
            <li>Tööta iteratiivselt (Develop iteratively)</li>
            <li>Suhtle pidevalt ja selgelt (Communicate continuously and clearly)</li>
            <li>Näita, et sul on asjade üle kontroll (Demonstrate control)</li>
            <li>Feature Driven Development (FDD)</li>
        </ul>
<h3>Näited agiilsest arengumudelist</h3>

    
    <img src="images/agile_Processesv1_2.webp" alt="">
    <p>Meeskonnad valivad ühe või kaks meetodit täielikult välja. Üks laialdasemalt kasutatavaid tehnikaid on Scrum ja XP, mis tavaliselt sulanduvad ideaalselt.
    </p>
    <p>Scrum on paindliku alamhulk ja XP on lisaks ka paindlik meetod tarkvara korduvaks tegemiseks.</h3>
    </p>

        
        

         
    </div>
    <button class="accordion">Spiral Model
    </button>
    <div class="panel">
        <p>Spiral Model is a risk-driven software development process model. It is a combination of waterfall model and
            iterative model. Spiral Model helps to adopt software development elements of multiple process models for
            the software project based on unique risk patterns ensuring efficient development process.</p>
        <p>Each phase of spiral model in software engineering begins with a design goal and ends with the client
            reviewing the progress. The spiral model in software engineering was first mentioned by Barry Boehm in his
            1986 paper.</p>

        <p>The development process in Spiral model in SDLC, starts with a small set of requirement and goes through each
            development phase for those set of requirements. The software engineering team adds functionality for the
            additional requirement in every-increasing spirals until the application is ready for the production phase.
            The below figure very well explain Spiral Model:</p>
        <img src="images/spiral_model.webp" alt="">
        <h3>When to use Spiral Model?</h3>
        <ul>
            <li>

                A Spiral model in software engineering is used when project is large

            </li>
            <li>
                When releases are required to be frequent, spiral methodology is used
            </li>
            <li>
                When creation of a prototype is applicable
            </li>
            <li>When risk and costs evaluation is important</li>
            <li>Spiral methodology is useful for medium to high-risk projects</li>
            <li>When requirements are unclear and complex, Spiral model in SDLC is useful</li>
            <li>
                When changes may require at any time
            </li>
            <li>When long term project commitment is not feasible due to changes in economic priorities</li>

        </ul>

    </div>
    <button class="accordion">Big bang model </button>
    <div class="panel">
        <p>The Big bang model is focusing on all types of resources in software development and coding, with no or very
            little planning. The requirements are understood and implemented when they come.
            This model works best for small projects with smaller size development teams which are working together. It
            is also useful for academic software development projects. It is an ideal model where requirements are
            either unknown or final release date is not given.
        </p>
    </div>
    <script>
        var acc = document.getElementsByClassName("accordion");
        var i;

        for (i = 0; i < acc.length; i++) {
            acc[i].addEventListener("click", function () {
                this.classList.toggle("active");
                var panel = this.nextElementSibling;
                if (panel.style.display === "block") {
                    panel.style.display = "none";
                } else {
                    panel.style.display = "block";
                }
            });
        }
    </script>
</body>

</html>