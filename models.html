<!DOCTYPE html>
<html lang="en">
<link rel="stylesheet" href="css/style.css">

<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>SDLC Mudelid</title>
    <div class="topnav">
        <a class="active" href="#SDLC">SDLC mudelid</a>
        <a href="programmingstyles.html" title="">Programmeerimisstiilid</a>

    </div>
</head>

<body>
    <h2 id="SDLC">SDLC mudelid</h2>

    <button class="accordion">Koskmudel</button>
    <div class="panel">
        <p>Aastal 1970 räägiti esimest korda tarkvara loomise mudelist nimega waterfall (koskmudel, lineaarne mudel W. Royce 1970[Royce]) :</p>
        <img src="images/kosk.jpg" alt="waterfall">
        <h3>Plussid</h3>
        <p>Koskmudeli eelised: selged põhjused-tagajärjed, struktuur, juhtidel on lihtsam jälgida, kas projekt on graafikus, väljamaksed konkreetsete etappide eest.</p>
        <p>Mõnikord on see ainuvõimalik lahendus.</p>
        <p>Näiteks on koskmudel endiselt väga laialt kasutusel, kui tellijaks on riigiasutus. Samuti on mõistlik selle mudeli kasutamine väga väikeste projektide puhul, kus nõuded on selged, ei muutu ning neid ei tule juurde.</p>
        <h3>Miinused</h3>
        <p>Koskmudeli puudusteks on kõrge hind, väga pikk valmimisaeg, palju dokumente: iga tagasiminek on väga kallis, igal etapil tehtud muudatus nõuab järgmiste etappide uuesti läbimist ning dokumenteerimist.</p>
        <p>On olnud palju projekte, mis lõpetati ning võeti vastu, kuid pole kunagi kasutusele võetud: aja jooksul muutusid nõuded nii palju, et valmistarkvara polnud enam vajalik (suure süsteemi kõikide vajaduste peensusteni kirja panemisele võib minna
            mitu aastat ning paar metsamassiivi dokumentatsiooni koostamisele).</p>

        <h3>Millal kasutatakse koskmudelit?</h3>
        <ul>
            <li>kui nõuded on teada ning need on lõplikud ega muutu protsessi käigus;
            </li>
            <li>on teada, mis tehnoloogiaid kasutada;
            </li>
            <li>projekt ei ole liiga pikk;
            </li>
            <li>tellija võib olla huvitatud selle mudeli kasutamisest, kui tal ei ole ressursi tegeleda projektiga pidevalt, vaid ainult tellimise (nõuete kogumise) ning testimise ajal.</li>
        </ul>
    </div>

    <button class="accordion">Iteratiivne mudel</button>
    <div class="panel">
        <p>Iteratiivne mudel võeti kasutusele <b>1980.</b> aastal. </p>
        <p> Iteratiivse mudeli puhul valmistatakse toote esimene variant, see vaadatakse üle, otsustatakse, kas on valitud õige tee. Algab uus iteratsioon: toodet täiendatakse, see vaadatakse üle, otsustatakse, kas on valitud õige tee. Algab uus iteratsioon…
            kuni toode saab valmis.</p>
        <p>Iteratiivse mudeli puhul on kogu protsess jagatud mitmeks etapiks (siin ja edasi – iteratsioon), iga iteratsioon kestab 2-6 nädalat. Alguses valmistatakse tarkvara kriitilisem osa, sisuliselt jälgitakse seejuures samu samme, mida koskmudeli puhul.
            Järgmise iteratsiooni ajal täiendatakse tarkvara, luues uue funktsionaalsuse või täiendades seda, mis oli varem tehtud. Iteratsioone korrutatakse projekti lõpetamiseni. Kui tarkvara on valmis, võetakse see kasutusele. Protsessi paremaks suunamiseks
            võetakse arvesse riskianalüüsi tulemusi. Iteratiivset mudelit võib näidata järgmiselt:</p>


        <img src="images/iteratsioon.jpg" alt="">
        <p>Iteratiivse mudeli raamistikud on näiteks RUP (The Rational Unified Process), EUP (The Enterprise Unified Process).
        </p>

        <h3>Millal kasutatakse?</h3>

        <ul>
            <li>
                On olemas üldine pilt, mida tahetakse saavutada. Väiksemaid ülesandeid saab täpsustada hiljem.
            </li>
            <li>
                Projekt on suur. Kui on oht, et projekt venib pikaks, tasub võtta kasutusele iteratiivne mudel, kuna see lubab rakendada paralleelseid iteratsioone: minimeerib riski, et projekti lõpuks muutuvad tarkvara vajadused/nõudmised.
            </li>

        </ul>

    </div>

    <button class="accordion">V Model</button>
    <div class="panel">
        <p>the V model of testing was developed where for every phase, in the Development life cycle there is a corresponding Testing phase</p>
        <img src="images/052715_0904_GuidetoSDLC3.webp" alt="">
        <ul>
            <li>

                The left side of the model is Software Development Life Cycle – SDLC</li>
            <li>The right side of the model is Software Test Life Cycle – STLC</li>
            <li>The entire figure looks like a V, hence the name V – model</li>

        </ul>
        <p>Apart from the V model, there are iterative development models, where development is carried in phases, with each phase adding a functionality to the software. Each phase comprises its independent set of development and testing activities.</p>

        <p>Good examples of Development lifecycles following iterative method are Rapid Application Development, Agile Development
        </p>
    </div>
    <button class="accordion">Agiilne mudel</button>
    <div class="panel">
        <h3>Mis on agiilne mudel?</h3>
        <p>Agiilne mudeliprotsess SDLC-s hõlbustab arendajaid meeskonnaga suhtlemisel ja annab kliendile käimasoleva projekti kohta täieliku ülevaate ning arendaja teeb vajadusel muudatusi. See paneb arendajad muudatusi tegema vastavalt kliendi interaktsioonile
            ja säästab ümbertöötamisel palju aega. Kuna see lähenemine töötab arendamisel ja testimisel käsikäes, töötavad arendajad ja testijad koos</p>
        <h3>Millal hakati kasutama?</h3>
        <p>1990. aastate alguses lõid Ken Schwaber ja Jeff Sutherland Scrumi metoodika</p>
        <img src="images/agiilne.jpg" alt="">
        <h3>Miks just agiilne meetod?</h3>
        <p>Agiilse mudeli peamised eelised on kiirus, reageerimine olukorra muutustele, inimeste suhtlemine. Tellija on motiveeritud liikuma koos projekti meeskonnaga, ta on ise ka meeskonna liige ja kaasatud kogu protsessi.
        </p>

        <ul>
            <li>Tellija rahulolu – uus tarkvara tarnitakse tihti ja kiiresti.</li>
            <li>Inimesed on protsessidest olulisemad: kõik projektis osalevad inimesed on pidevas suhtlemises, mõjutades tulemust.
            </li>
            <li>Projektis osalejad saavad kiiresti tagasisidet, kas see, mis tehti, on vajalik.</li>
            <li>Olukorra muutmisel saab toodet kiiresti muuta.</li>
            <li>Nõudeid saab muuta isegi väga hilisel projekti etapil.</li>
            <li>Dokumenteerimine on minimaalne: puhas isedokumenteeriv kood tähendab, et tekib vähem dokumente (mida keegi ei loe) ning koodi puhtana hoidmine on arendaja ülesandeks, ehk on suurem tõenäosus, et dokumentatsioon (minimaalne arv dokumente +
                isedokumenteeriv kood) on aktuaalne.</li>
        </ul>
        <h3>Millal kasutada?</h3>
        <p>Agiilne mudel sobib, kui:</p>
        <ul>
            <li>meeskond (tooteomanik, arendustiim) on väga tugev;</li>
            <li>on soov projektiga kiiresti alustada (ei vaja pikka analüüsi faasi);</li>
            <li> on tõenäosus, et mõned nõuded ilmnevad hiljem;</li>
            <li>rahastus ei ole probleemiks.</li>
        </ul>
        <h3>Näited agiilsest arengumudelist</h3>
        <img src="images/agile_Processesv1_2.webp" alt="">
        <p>Meeskonnad valivad ühe või kaks meetodit täielikult välja. Üks laialdasemalt kasutatavaid tehnikaid on Scrum ja XP, mis tavaliselt sulanduvad ideaalselt.
        </p>
        <p>Scrum on paindliku alamhulk ja XP on lisaks ka paindlik meetod tarkvara korduvaks tegemiseks.</h3>
        </p>
    </div>
    <button class="accordion">Spiraal mudel
    </button>
    <div class="panel">
        <p>Spiraalmudelit kirjeldas esimest korda Barry Boehm oma 1986 a. artiklis. Protsessi kulgemist kujutab spiraal. Esimene kordus võib olla näiteks seotud süsteemi teostatavuse uurimisega, teine nõudmiste kirjeldamisega, järgmine kavandamisega jne.
            Mitu kordust on enamasti seotud tarkvara realiseerimisega, kus tema ehitamine toimub inkrementaalselt. Kuid kindlasti ei tohiks spiraali korduseid võrdsustada tavapäraste arendusprotsessi faasidega. Iga kordus on jaotatud 3 kuni 6 sektorisse
            (erinevad autorid jagavad erinevalt). Iga kordus algab lähema eesmärgi kavandamise ja riskide hindamisega ning lõppeb nö kliendiga - ehk eesmärk peab saama täidetud ja kontrollitud. Sektorite töömahukus ei pruugi olla ühesugune. Boehm'i järgi
            on sektoreid neli</p>
        <p>Each phase of spiral model in software engineering begins with a design goal and ends with the client reviewing the progress. The spiral model in software engineering was first mentioned by Barry Boehm in his 1986 paper.</p>

        <p>The development process in Spiral model in SDLC, starts with a small set of requirement and goes through each development phase for those set of requirements. The software engineering team adds functionality for the additional requirement in every-increasing
            spirals until the application is ready for the production phase. The below figure very well explain Spiral Model:
        </p>
        <img src="images/spiral_model.webp" alt="">
        <h3>When to use Spiral Model?</h3>
        <ul>
            <li>

                A Spiral model in software engineering is used when project is large

            </li>
            <li>
                When releases are required to be frequent, spiral methodology is used
            </li>
            <li>
                When creation of a prototype is applicable
            </li>
            <li>When risk and costs evaluation is important</li>
            <li>Spiral methodology is useful for medium to high-risk projects</li>
            <li>When requirements are unclear and complex, Spiral model in SDLC is useful</li>
            <li>
                When changes may require at any time
            </li>
            <li>When long term project commitment is not feasible due to changes in economic priorities</li>

        </ul>

    </div>

    <script>
        var acc = document.getElementsByClassName("accordion");
        var i;

        for (i = 0; i < acc.length; i++) {
            acc[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var panel = this.nextElementSibling;
                if (panel.style.display === "block") {
                    panel.style.display = "none";
                } else {
                    panel.style.display = "block";
                }
            });
        }
    </script>
</body>

</html>